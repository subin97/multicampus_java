# Day 7
---
### 다형성
> 여러 가지 형태를 가질 수 있는 능력, 즉 하나의 코드로 다양한 데이터를 처리하는 것.  
조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있도록 함.

- 부모 타입에 존재하는 멤버에만 접근가능함.
- 부모에 존재하는 멤버가 자식에도 존재한다면 부모에 존재하니 접근은 가능하지만 실제 접근은 자식의 것으로 호출(동적 바인딩)

~~~java
// Tv.java
class Tv {
  boolean power;
  int channel;
  void power(){ power = !power; };
  void channelUp(){ ++channel; };
  void channelDown(){ --channel; };
}
~~~
~~~java
// CaptionTv.java
class CaptionTv extends Tv {
  String text;
  void caption(){ /*내용생략*/ }
}
~~~
~~~java
CaptionTv c = new CaptionTv();
Tv t = new CaptionTv();
~~~
- t는 CaptionTv의 멤버인 text와 caption을 사용할 수 없음
- c, t 둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라짐.

### 참조변수의 형변환
> 자손타입 -> 조상타입(Up-casting) : 형변환 생략가능  
자손타입 <- 조상타입(Down-casting) : 형변환 생략불가

### 객체 지향의 여러 가지 속성들
- 변수 : 프로그램 동작 중 상태를 기억
- 제어문 : 프로그램의 동작을 분기 혹은 반복, 공통된 패턴을 묶음
- 함수 : 프로그램의 자주 사용되는 명령문을 재사용, 공통된 명령문 집합을 묶음
- 클래스 : 프로그램에서 사용될 사용자 정의 자료형, 관련있는 변수와 함수를 묶음
- 상속 : 여러 클래스 간의 공통된 형태를 수직적으로 뽑아냄  
-> 수직적으로 공통점 묶음
- 다형성 : 형태는 같지만 내부 동작이 다른 함수까지 뽑아낼 수 있도록 함  
-> 수평적으로 공통점 묶음  
-> Framework(Library+구조)


### 추상 클래스
> 몸체가 구현되지 않은 메소드를 가지고 있는 클래스  
abstract 키워드가 붙음  

- **추상클래스는 객체(인스턴스)를 생성할 수 없다.**
- 미완성인 부분에 대해 일회성으로 구현하면 객체 생성 가능(익명 클래스)

### 추상 메소드
> 몸체가 구현되지 않은 메소드  
메소드 앞에 abstract 키워드가 붙음  
추상 메소드를 사용하려면 추상 클래스 안에 있어야 함.

### Design Pattern
> 자주 사용하는 설계 형태를 정형화해서 이를 유형별로 설계 템플릿을 만들어둔 것

- 효율성, 재사용성 높일 수 있음
- 유사한 상황에서 구조적인 문제를 해결할 수 있는 방안 제시
##### 템플릿 메소드 패턴
- 템플릿이란 하나의 '틀'을 의미
- 상위 클래스(추상 클래스)에서 추상메서드를 통해 기능의 골격 제공, 하위 클래스에서는 메서드의 세부 처리 구체화

### SOLID 원칙
1. **SRP : 단일 책임의 원칙**
  - 한 클래스는 하나의 책임만 가져야 한다.
  - **하나 하나의 기능별로 클래스를 생성하는 것이 좋다.**
2. OCP : 개방폐쇄의 원칙
  - 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
3. LSP : 리스코브 치환의 원칙
  - 프로그램의 객체 프로그램의 정확성을 깨뜨리지 않으면서 하위 인스턴스로 바꿀 수 있어야 한다.
4. ISP : 인터페이스 분리의 원칙
    - 자신이 이용하지 않는 메서드에 의존하지 않아야 한다.
5. **DIP : 의존성 역전의 원칙**
  - 상위 계층이 하위 계층에 의존하는 전통적인 의존 관계를 역전시킴으로써 상위 계층이 하위계층의 구현으로부터 독립되게 할 수 있다.
  - **하위 계층이 상위 계층에서 정의한 추상 타입에 의존해야 한다.**
  - 프로그램은 추상화에 의존해야지 구체화에 의존하면 안된다.
  ~~~java
  public class Mazinga extends Robot{
  	// private MissileAttack attack;
  	private Attack attack
    // 부모 클래스 이용 : 타입 의존성을 느슨하게 만듬
  	private WalkingMove move;
  	public Mazinga() {
  		attack=new MissileAttack();
  		move=new WalkingMove();
  	}
  	@Override
  	public void attack() {
  		attack.attack();
  	}
  	@Override
  	public void move() {
  		move.move();
  	}
  }
  ~~~
